#include <cuda_runtime.h>
#include <stdio.h>
#include <string.h>

__global__ void calculate_matches(const char *cipher, int length, int *matches) {
    int shift = blockIdx.x * blockDim.x + threadIdx.x;
    if (shift >= length) return; // Ensure we do not go out of bounds

    int matchCount = 0;
    for (int i = 0; i < length; ++i) {
        if (cipher[i] == cipher[(i - shift + length) % length]) {
            ++matchCount;
        }
    }
    matches[shift] = matchCount;
}
double mean(const int arr[], int size) {
    double sum = 0;
    for (int i = 0; i < size; i++) {
        sum += arr[i];
    }
    return sum / size;
}

double variance(const int arr[], int size, double mean) {
    double sum = 0;
    for (int i = 0; i < size; i++) {
        sum += (arr[i] - mean) * (arr[i] - mean);
    }
    return sum / size;
}

int mode(const int arr[], int size) {
    int maxValue = 0, maxCount = 0;

    for (int i = 0; i < size; ++i) {
        int count = 0;
        for (int j = 0; j < size; ++j) {
            if (arr[j] == arr[i]) ++count;
        }
        
        if (count > maxCount) {
            maxCount = count;
            maxValue = arr[i];
        }
    }
    return maxValue;
}

int guess_key_length_cuda(const char *cipher) {
    int length = strlen(cipher);
    char *d_cipher;
    int *d_matches, *matches;

    cudaMalloc((void **)&d_cipher, length);
    cudaMalloc((void **)&d_matches, length * sizeof(int));

    cudaMemcpy(d_cipher, cipher, length, cudaMemcpyHostToDevice);

    int threadsPerBlock = 256;
    int blocks = (length + threadsPerBlock - 1) / threadsPerBlock;

    calculate_matches<<<blocks, threadsPerBlock>>>(d_cipher, length, d_matches);

    matches = (int *)malloc(length * sizeof(int));
    cudaMemcpy(matches, d_matches, length * sizeof(int), cudaMemcpyDeviceToHost);




     double dat_means = mean(matches + 1, length - 1);
    double dat_std_dev = sqrt(variance(matches + 1, length - 1, dat_means));

    int* peaks = (int*)malloc(length * sizeof(int));
    int peaks_count = 0;
    for (int i = 0; i < length; i++) {
        if (matches[i] >= dat_std_dev + dat_means) {
            peaks[peaks_count++] = i;
        }
    }

    // Calculate differences between peaks
    int* peak_diff = (int*)malloc((peaks_count - 1) * sizeof(int));
    for (int i = 0; i < peaks_count - 1; i++) {
        peak_diff[i] = peaks[i + 1] - peaks[i];
    }

    int key_length = mode(peak_diff, peaks_count - 1);



    cudaFree(d_cipher);
    cudaFree(d_matches);
    free(matches); // Note: Before freeing, you'd use 'matches' to calculate the key length
    free(peaks);
    free(peak_diff);

    return key_length;
}

int main() {
    char* encrypted = "CXYFNEPVNITAKXGGXMQUKPAMVERWNEQLRIQIEEPWBSMLYJRZOZYJSELUOEJLOVLSDMTWVCGLSWASVGSDKXCVLCDAXHGFQXFWWIYFYJYVKXYKOXDAXHGFQXFWNMDXOVCFMIMXOEAZNERSZSGFDXMLRIKWKRQIEEPAXKRZOHGXPIPWXGCKKHBAXKRZOQRGQIRZOVBAFMBAXKZQDLCFEQZWBSDHYMLLCMLLRIBSDEQWDPCKCELVPMLVSRELRIQIEEPWBSMLCXYFNEPVNITAKXGGXMQAWTMJDELLLIASEWCADGYFRIJHEWCJCEQKOWQJSWIUYRQANIPSXMLNOWREORRGZXGGXAGLRELSFIPSQIYFXYYDBIRMBRMXZIPQOEPZYACNOVRZSWYNOVYYOAYKNIPAFIBXBSKLRINSCXRZBICQOEPJOXSJXWMXWELQFEJMOWZQMEJUEPYLSRELRIQLKRBSBHBWFMYLSSLSXHSFNIPKDELVSREQYYPDYAJAUIJARSMVYJYUDYYDVCYNOVYYSREAXELQCMLYVIEAFILQOEPQYYPTOXRWBEPEOHRGWEIWSRDGBQCVNIAACMMFCELVBIAGQRGRSREMXHCJVCGFQVGKUWRSXHYJNHCNSERAYRGKMEJUEPYLOHYKDLCKAYYJOVMGDSDLRITSBMYFMIYDDIPFKXGNOPWADMQUKPAMVERWNFWXSRBAXKRZOQCSXSDSNERSCIRXSRBAXKRZOHGXPIPWXGCGPIYURHYLKTMAXXRGDLCEOELKAYYJSRELRIBAPJCJORAWCEBVSRELRIKLYKCLRIPVSZGVSRETIXFWXYKTOVMXZSGFDWGFDLCVKXYKOXJWCWYFNJGFNMLYDLCKAYYJOVMGDWRSXHYJNHCNSERAYRGKSQNGBXYFDFCUKYQWSXASXLCDZYQWBWYKCIQKBMQCMSLKSHCJKRGFFIQLWILLYTRAYRUADLYFKZCJKKCSXRSSVVCLEVLGPTCJIIYJRSUWFIPLRMQSFIPSQIUSCHCJSZCVPVMEDLCHKWRLRVCWIIYJBIRMBRQGPQYFIZYDEIQTIGYDMYJSDMLYDLCKDELVKVBVOZGSDMMFKRBMXHCJCXYFNMLYISSJVSUDSOCDSLMGNSDSMXSSVPWSFIPSQMLYSRYFIWGFQPCYSZCFIIYJISSJLIRLOVYJWIBLYQYCOMLXYVKWNHCUSWGGXWYFNVCUYKLAJMLYERBWBPWAXKPACOQLKRBSBHBWFMYLSSLACGYDMYJSDIBSCXFWCUSSBIPGYXMXDLCNKVGSXGCSVXCJXERAFIJQSXGKMEJUEPYLOHZQPMLVSRELRIKWKRMXKHYLKWCLPMLVSRELRIBAPJCJORAWYJCSMLBSDENGSRRLYXFWWIYFCUSSBMLYDLCVSJDWBILUOWYVNMLYDLCEDSEWDLCJNMTANMLYLCRZORSELIPGPTMAXXQAXXFWNERSCIRDOWQSXHDAXHGFQXFWCUSSBIPGYXQLKRBSBHBWFMYLSSLACMKHYVRSXXZWMESKOMRUKRFWVTSKOVQSCWCKCVGKUGMFCMBWBELAXZCKDQCFDSNLSSLOSXFSXETWBEEWKRLMKPPWDYPFYJNWBCCSBLMOOZCJDLGKKZCJKKCOKWBWBMTWNJPGWXFWZEQLDLPWOCCSBVCLEVLKYJKSXCTSVYCKLCASVGSDKXGFQXFWCXYFNEPVNITAKXGGXELVERBWBWRSXHGFQCMMBPMOVMIWVMFGYHMXKGRMKPJQKZCJKKGFQMLSXCQAXKJWQMTWXCCSBCMMBFCLDIPSBQCVDSKSUIGFPSPEOHBWMMQAYRQSXHPWMSEFSDGFQYLVOVJQSREJSWIKDELVKVBVOZGSDMMFSWASVGSDKXCVKWRZOWOMKVCJYSRGPXFWFEPAKRAWKPRWBRYLSZCDIMRACGYDMYJSDIBTIJGFNMLYDLCEOELGPEBSDEQWDJGFNMLYDLCVSJDWBILUOSDWKGFVKXYHYMLLDSRZOQCSXWOMKVGFQXFWNMDXOVCFMIQSNHGFQXFWWXMYOXFWBHGNSHGFQFWLRILMWFCJYJNGSRRKSRRZOHYLKWCLVIQKKRBXSRBAXKRZOWOMKVCJYSRKDELVKVBVOZGSDMMFSWGEZSPLKRRTOGYMCIGLMELZOPNMCIPKKWQWCWPACOAGXWGVOVYFSRTWCXKWXXMHDMMFGMRZKRYNOVYYOELFEEJJOXSJXSDHOVWWKVFGGITWBXFACETWBEEWGEQVOVGNOHDJYQRZOTYKDXFJOIWWKVPWDYPFCSDEKRWNKPSWCFWUKPAMVERAXKRZOWRSXHYJNHCNSERAYRYFNYLVOVQLKRBAXKWGEVJGGPGCOPGZYSBGPEALEEJDIETWBEEAXKGFKRWKSREDOKGNORWWKVWGEVZWDXCJKVKWNXMEKOCAXJMJWIBVOGGKSSLKKRBJOGMYXMXAXKSFNIPDIMLYBMQCCXYFNEPVNITAKXGGXMQUKPAMVERWNEQLRIQIEEPWBSMLYJRZOZYJSELUOEJLOVLSDMTWVCGLSWASVGSDKXCVLCDAXHGFQXFWWIYFYJYVKXYKOXDAXHGFQXFWNMDXOVCFMIMXOEAZNERSZSGFDXMLRIKWKRQIEEPAXKRZOHGXPIPWXGCKKHBAXKRZOQRGQIRZOVBAFMBAXKZQDLCFEQZWBSDHYMLLCMLLRIBSDEQWDPCKCELVPMLVSRELRIQIEEPWBSMLCXYFNEPVNITAKXGGXMQAWTMJDELLLIASEWCADGYFRIJHEWCJCEQKOWQJSWIUYRQANIPSXMLNOWREORRGZXGGXAGLRELSFIPSQIYFXYYDBIRMBRMXZIPQOEPZYACNOVRZSWYNOVYYOAYKNIPAFIBXBSKLRINSCXRZBICQOEPJOXSJXWMXWELQFEJMOWZQMEJUEPYLSRELRIQLKRBSBHBWFMYLSSLSXHSFNIPKDELVSREQYYPDYAJAUIJARSMVYJYUDYYDVCYNOVYYSREAXELQCMLYVIEAFILQOEPQYYPTOXRWBEPEOHRGWEIWSRDGBQCVNIAACMMFCELVBIAGQRGRSREMXHCJVCGFQVGKUWRSXHYJNHCNSERAYRGKMEJUEPYLOHYKDLCKAYYJOVMGDSDLRITSBMYFMIYDDIPFKXGNOPWADMQUKPAMVERWNFWXSRBAXKRZOQCSXSDSNERSCIRXSRBAXKRZOHGXPIPWXGCGPIYURHYLKTMAXXRGDLCEOELKAYYJSRELRIBAPJCJORAWCEBVSRELRIKLYKCLRIPVSZGVSRETIXFWXYKTOVMXZSGFDWGFDLCVKXYKOXJWCWYFNJGFNMLYDLCKAYYJOVMGDWRSXHYJNHCNSERAYRGKSQNGBXYFDFCUKYQWSXASXLCDZYQWBWYKCIQKBMQCMSLKSHCJKRGFFIQLWILLYTRAYRUADLYFKZCJKKCSXRSSVVCLEVLGPTCJIIYJRSUWFIPLRMQSFIPSQIUSCHCJSZCVPVMEDLCHKWRLRVCWIIYJBIRMBRQGPQYFIZYDEIQTIGYDMYJSDMLYDLCKDELVKVBVOZGSDMMFKRBMXHCJCXYFNMLYISSJVSUDSOCDSLMGNSDSMXSSVPWSFIPSQMLYSRYFIWGFQPCYSZCFIIYJISSJLIRLOVYJWIBLYQYCOMLXYVKWNHCUSWGGXWYFNVCUYKLAJMLYERBWBPWAXKPACOQLKRBSBHBWFMYLSSLACGYDMYJSDIBSCXFWCUSSBIPGYXMXDLCNKVGSXGCSVXCJXERAFIJQSXGKMEJUEPYLOHZQPMLVSRELRIKWKRMXKHYLKWCLPMLVSRELRIBAPJCJORAWYJCSMLBSDENGSRRLYXFWWIYFCUSSBMLYDLCVSJDWBILUOWYVNMLYDLCEDSEWDLCJNMTANMLYLCRZORSELIPGPTMAXXQAXXFWNERSCIRDOWQSXHDAXHGFQXFWCUSSBIPGYXQLKRBSBHBWFMYLSSLACMKHYVRSXXZWMESKOMRUKRFWVTSKOVQSCWCKCVGKUGMFCMBWBELAXZCKDQCFDSNLSSLOSXFSXETWBEEWKRLMKPPWDYPFYJNWBCCSBLMOOZCJDLGKKZCJKKCOKWBWBMTWNJPGWXFWZEQLDLPWOCCSBVCLEVLKYJKSXCTSVYCKLCASVGSDKXGFQXFWCXYFNEPVNITAKXGGXELVERBWBWRSXHGFQCMMBPMOVMIWVMFGYHMXKGRMKPJQKZCJKKGFQMLSXCQAXKJWQMTWXCCSBCMMBFCLDIPSBQCVDSKSUIGFPSPEOHBWMMQAYRQSXHPWMSEFSDGFQYLVOVJQSREJSWIKDELVKVBVOZGSDMMFSWASVGSDKXCVKWRZOWOMKVCJYSRGPXFWFEPAKRAWKPRWBRYLSZCDIMRACGYDMYJSDIBTIJGFNMLYDLCEOELGPEBSDEQWDJGFNMLYDLCVSJDWBILUOSDWKGFVKXYHYMLLDSRZOQCSXWOMKVGFQXFWNMDXOVCFMIQSNHGFQXFWWXMYOXFWBHGNSHGFQFWLRILMWFCJYJNGSRRKSRRZOHYLKWCLVIQKKRBXSRBAXKRZOWOMKVCJYSRKDELVKVBVOZGSDMMFSWGEZSPLKRRTOGYMCIGLMELZOPNMCIPKKWQWCWPACOAGXWGVOVYFSRTWCXKWXXMHDMMFGMRZKRYNOVYYOELFEEJJOXSJXSDHOVWWKVFGGITWBXFACETWBEEWGEQVOVGNOHDJYQRZOTYKDXFJOIWWKVPWDYPFCSDEKRWNKPSWCFWUKPAMVERAXKRZOWRSXHYJNHCNSERAYRYFNYLVOVQLKRBAXKWGEVJGGPGCOPGZYSBGPEALEEJDIETWBEEAXKGFKRWKSREDOKGNORWWKVWGEVZWDXCJKVKWNXMEKOCAXJMJWIBVOGGKSSLKKRBJOGMYXMXAXKSFNIPDIMLYBMQCCXYFNEPVNITAKXGGXMQUKPAMVERWNEQLRIQIEEPWBSMLYJRZOZYJSELUOEJLOVLSDMTWVCGLSWASVGSDKXCVLCDAXHGFQXFWWIYFYJYVKXYKOXDAXHGFQXFWNMDXOVCFMIMXOEAZNERSZSGFDXMLRIKWKRQIEEPAXKRZOHGXPIPWXGCKKHBAXKRZOQRGQIRZOVBAFMBAXKZQDLCFEQZWBSDHYMLLCMLLRIBSDEQWDPCKCELVPMLVSRELRIQIEEPWBSMLCXYFNEPVNITAKXGGXMQAWTMJDELLLIASEWCADGYFRIJHEWCJCEQKOWQJSWIUYRQANIPSXMLNOWREORRGZXGGXAGLRELSFIPSQIYFXYYDBIRMBRMXZIPQOEPZYACNOVRZSWYNOVYYOAYKNIPAFIBXBSKLRINSCXRZBICQOEPJOXSJXWMXWELQFEJMOWZQMEJUEPYLSRELRIQLKRBSBHBWFMYLSSLSXHSFNIPKDELVSREQYYPDYAJAUIJARSMVYJYUDYYDVCYNOVYYSREAXELQCMLYVIEAFILQOEPQYYPTOXRWBEPEOHRGWEIWSRDGBQCVNIAACMMFCELVBIAGQRGRSREMXHCJVCGFQVGKUWRSXHYJNHCNSERAYRGKMEJUEPYLOHYKDLCKAYYJOVMGDSDLRITSBMYFMIYDDIPFKXGNOPWADMQUKPAMVERWNFWXSRBAXKRZOQCSXSDSNERSCIRXSRBAXKRZOHGXPIPWXGCGPIYURHYLKTMAXXRGDLCEOELKAYYJSRELRIBAPJCJORAWCEBVSRELRIKLYKCLRIPVSZGVSRETIXFWXYKTOVMXZSGFDWGFDLCVKXYKOXJWCWYFNJGFNMLYDLCKAYYJOVMGDWRSXHYJNHCNSERAYRGKSQNGBXYFDFCUKYQWSXASXLCDZYQWBWYKCIQKBMQCMSLKSHCJKRGFFIQLWILLYTRAYRUADLYFKZCJKKCSXRSSVVCLEVLGPTCJIIYJRSUWFIPLRMQSFIPSQIUSCHCJSZCVPVMEDLCHKWRLRVCWIIYJBIRMBRQGPQYFIZYDEIQTIGYDMYJSDMLYDLCKDELVKVBVOZGSDMMFKRBMXHCJCXYFNMLYISSJVSUDSOCDSLMGNSDSMXSSVPWSFIPSQMLYSRYFIWGFQPCYSZCFIIYJISSJLIRLOVYJWIBLYQYCOMLXYVKWNHCUSWGGXWYFNVCUYKLAJMLYERBWBPWAXKPACO";
    int keyLength = guess_key_length_cuda(encrypted);
    printf("Guessed key length: %d\n", keyLength);

    return 0;
}
